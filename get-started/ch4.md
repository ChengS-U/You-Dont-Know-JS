# 你不知道的 JavaScript：入门 —— 第 2 版
# 第 4 章：大局观

本书调查了你在*开始*学习 JS 时需要注意的事项。目的是为了填补新接触 JS 的读者在早期接触这门语言时可能会被绊倒的坑。我也希望我们在整个过程中提示了足够多的更深层的细节，以激发你的好奇心，让你想更深入地了解这门语言。

我们将在本系列的其他书籍中解读语言的其他部分，比我们在这里的几个简短章节中所能做的要更详细。

不过，记得要慢慢来。与其急着去看下一本书，试图快速地看完所有的书，不如花点时间回味一下本书中的内容。多花一些时间查看你当前项目中的代码，并将你所看到的与迄今为止所讨论的内容进行比较。

当你准备好了，这最后一章将 JS 语言的组织划分为三大支柱，然后提供一个简短的路线图，说明从本系列其余部分中你可以期待的内容，以及我对如何继续学习的建议。另外，不要跳过附录，尤其是附录 B，“练习、练习、练习！”。

## 支柱 1：作用域和闭包

将变量组织成作用域单元（函数、块）是任何语言最基础的特性之一；也许没有其他特性对程序的行为方式有更大的影响。

作用域就像桶，而变量就像你放进这些桶里的弹珠。语言的作用域模型就像帮助你确定哪些颜色的弹珠应该放在哪些匹配颜色的桶里的规则。

作用域互相嵌套，对于任何给定的表达式或语句，只能访问在该级别的作用域嵌套中的，或在较高/较外的作用域中的变量；较低/较内的作用域中的变量是隐藏的，不可访问的。

这就是大多数语言中的作用域的表现，也就是所谓的词法作用域。作用域单元的边界，以及变量在其中的组织方式，是在程序被分析（编译）时确定的。换句话说，这是由作者的决定：你的程序中的函数/作用域的位置决定了程序中这部分作用域的结构是什么。

JS 使用的是词法作用域，尽管很多人声称它不是，因为它的模型有两个特殊的特性，而这两个特性在其他词法作用域语言中是不存在的。

第一种情况通常被称为*提升*：在作用域中任何地方声明的变量都被视为在作用域的开始处声明的。另一种是，`var` 声明的变量是函数作用域内的，即使它们出现在一个块中。

无论是提升还是函数作用域的 `var` 都不足以支持 JS 不是词法作用域的说法。`let`/`const` 声明有一种奇特的错误行为，称为 “临时死亡区”（TDZ），它导致了可观察但不可用的变量。虽然遇到 TDZ 是奇怪的，但它*也*不能证明不是词法作用域。所有这些都只是语言中独特的部分，所有 JS 开发人员都应该学习和理解。

当语言将函数作为第一类值时，闭包是词法作用域的自然结果，JS 就是这样。当一个函数对一个外部作用域的变量进行引用时，该函数作为一个值被传来传去，并在其他作用域中执行，它会保持对其原始作用域变量的访问，这就是闭包。

在所有的编程中，特别是在 JS 中，闭包驱动了许多最重要的编程模式，包括模块。在我看来，模块在 JS 代码组织方面，是最*符合规律*的。

要进一步挖掘作用域、闭包以及模块如何工作，请阅读第二本书 *《作用域和闭包》*。

## 支柱 2：原型

该语言的第二个支柱是原型系统。我们在第 3 章（“原型”）中深入地介绍了这个话题，但我只想对它的重要性多说几句。

JS 是为数不多的可以选择直接显式地创建对象的语言之一，而不需要先在类中定义它们的结构。

多年来，人们在原型之上实现了类的设计模式 —— 所谓的 “原型继承”（见附录 A，“原型类”）—— 然后随着 ES6 的 `class` 关键字的出现，这门语言加倍地倾向于 OO/类式编程。

但我认为这种关注掩盖了原型系统的美感和力量：两个对象通过共享一个 `this` 上下文来简单地相互连接并动态合作（在函数/方法执行过程中）的能力。

类只是你可以在这种能力之上建立的一种模式。但另一种方向截然不同的方法是，简单地把对象作为对象，完全忘记类，让对象通过原型链进行合作。这就是所谓的*行为委托*。我认为委托比类继承更强大，是我们程序中组织行为和数据的一种手段。

但类继承几乎得到了所有的关注。其余的则是函数式编程（FP），作为一种 “非类” 的程序设计方式。这让我很难过，因为它扼杀了探索委托作为一种可行的选择的机会。

我鼓励你花大量的时间深入阅读第三册 *《对象和类》*，看看对象委托是如何拥有比我们可能意识到的更大的潜力。这并不是一个反 “类” 的信息，而是特意的说 “类不是使用对象的唯一方式”，我希望更多的 JS 开发者考虑这个问题。

我认为，对象委托比类更符合 JS 的*规律*（稍后再谈*规律*）。

## 支柱 3：类型与强制

JS 的第三个支柱是迄今为止 JS 本质中被忽视最多的部分。

绝大多数开发人员对*类型*在编程语言中如何工作，特别是在 JS 中如何工作有很大的误解。广大 JS 社区的兴趣潮已经开始转向 “静态类型”，使用 TypeScript 或 Flow 等类型感知工具。

我同意 JS 开发者应该学习更多关于类型的知识，应该学习更多关于 JS 如何管理类型转换的知识。我也同意类型感知工具可以帮助开发者，前提是他们首先获得并使用了这些知识！

但我完全不同意由此认定 JS 的类型机制不好，并且我们需要用语言之外的解决方案来掩盖 JS 的类型这样的结论。我们不一定非要按照 “静态类型” 的方式，在程序中巧妙而扎实地处理类型。如果你愿意与众人*背道而驰*，而顺从 JS 的*规律*的话，还有其他的选择（以后会有更多的介绍）。

可以说，这个支柱比其他两个支柱更重要，因为如果 JS 程序不能正确地利用 JS 的值类型，以及类型之间的值转换（强制），那么任何 JS 程序都不会做任何有用的事情。

即使你喜欢 TypeScript/Flow，如果你不深入了解语言本身是如何管理值类型的，你也不会从这些工具或编码方法中得到最大的好处。

要想了解更多关于 JS 类型和强制的知识，请查阅第 4 册 *《类型和语法》*。但请不要因为你总是听说我们应该使用 `===` 而跳过这个话题，而忘记其他的内容。

如果不学习这个支柱，你的 JS 基础是不牢固的，至少也是不完整的。

## 符合规律

我有一些关于继续 JS 学习之旅，以及你在阅读本系列丛书其余部分的建议要与大家分享：要意识到*规律*（回忆本章前面对*规律*的各种提及）。

首先，考虑一下大多数人接近和使用 JS 的*规律*（如木头中的纹路）。你可能已经注意到，一些书在很多方面都与这种*纹路*相违背。在 YDKJSY 中，我足够尊重你这位读者，并解释了 JS 的所有部分，而不仅仅是一些精选的流行部分。我相信你们都有能力也值得拥有这些知识。

但这是你从很多其他资料中找不到的。这也意味着，你越是遵循和坚持这些书中的指导 —— 你自己仔细思考和分析你的代码中最好的是什么 —— 你就越会脱颖而出。这可能是一件好事，也可能是一件坏事。如果你想从人群中脱颖而出，你就必须从人群的做法中突破出来！

但我也有很多人告诉我，他们在求职面试时引用了这些书中的一些话题/解释，而面试官告诉应聘者他们错了；据说确实有人因此失去了工作机会。

在这些书中，我尽可能地提供关于 JS 的完全准确的信息，并从规范本身中获得信息。但是，我也会就如何在你的程序中解释和使用 JS 以获得最大的好处发表一些我的意见。我不会把观点当作事实，反之亦然。在这些书中，你总能知道哪个是事实。

关于 JS 的事实其实并不值得争论。要么规范说了什么，要么没有。如果你不喜欢规范说的东西，或者不喜欢我转述的东西，可以去找 TC39！如果你在面试中，他们声称你的说法是错误的，就在那时问他们，你是否可以在规范中查找它。如果面试官不肯重新考虑，那你无论如何也不要想在那里工作。

但如果你的选择与我的意见一致，你必须准备好用*为什么*你有这种感觉来支持这些选择。不要只是鹦鹉学舌。要拥有你的观点。为他们辩护。如果你希望与之合作的人不同意，请昂首挺胸地离开。JS 很大，有很多空间，可以有很多不同的方式。

换句话说，不要害怕违背*规律*，就像我对这些书和我所有的教导一样。没有人可以告诉你如何才能最好地利用 JS，那是你自己的决定。我只是想让你有能力得出自己的结论，无论结论是什么。

另一方面，有一个你真的应该关注和遵循*规律*：在语言层面的，JS 如何工作的*规律*。在 JS 中，有些事情只要有正确的实践和方法，就能很好地、很自然地工作，而有些事情你真的不应该在语言中尝试去做。

你能让你的 JS 程序看起来像一个 Java、C# 或 Perl 程序吗？那 Python 或 Ruby，甚至 PHP 呢？在不同程度上，你当然可以。但是你应该吗？

不，我不认为你应该。我认为你应该学习和接受 JS 的方式，让你的 JS 程序尽可能的实用。有些人会认为这意味着草率和不正规的编程，但我完全不是这个意思。我的意思只是说，JS 有很多模式和习惯是可以识别的 “JS”，顺着这种*规律*走，是通往最佳成功的通用路径。

最后，也许最重要的*规律*是要认识到你正在开发的程序，以及和你一起工作的开发人员是如何做事的。不要读了这些书，然后试图在一夜之间改变你现有项目中的*规律*。这种方法总是会失败的。

你必须随着时间的推移，一点一点地转变这些东西。努力和你的开发伙伴们建立共识，为什么要重新审视和重新考虑一种方法。但每次只用一个小话题来做，让前后代码对比来证明一切。把团队中的每个人都召集起来讨论，并推动基于代码中的分析和证据而做出的决策，而不是 “我们的高级开发人员总是这样做” 的惯性。

这是我能传授的帮助你学习 JS 的最重要的建议。总是不断寻找更好的方法使用 JS 给我们提供的东西来编写更可读的代码。每个在你的代码上工作的人，包括未来的自己，都会感谢你!

## 顺序

所以，现在你已经有了更广阔的视野，知道了JS中还有什么需要探索的地方，也有了对待接下来旅程的正确态度。

但在这一点上，我得到的最常见的实际问题之一是，“我应该以什么顺序阅读这些书？” 有一个直接的答案......但也要看情况。

我对大多数读者的建议是按照这个顺序阅读这个系列：

1. 从 *《入门》*（第一册）开始，打好 JS 的基础 —— 好消息，你已经快读完这本书了！

2. 在 *《作用域和闭包》*（第 2 册）中，挖掘 JS 的第一支柱：词法作用域，和它如何支持闭包，以及模块模式如何组织代码。

3. 在 *《对象和类》*（第 3 册）中，关注 JS 的第二支柱：JS 的 `this` 是如何工作的，对象原型是如何支持委托的，原型如何实现 OO 式代码组织中的 `class` 机制。

4. 在 *《类型和语法》*（第 4 册）中，解决 JS 的第三个也是最后一个支柱：类型和类型强制，以及 JS 的语法和它如何定义我们如何编写代码。

5. 在**三大支柱**稳固之后，*《同步和异步》*（第 5 册）接着探讨我们如何使用流控制来模拟程序中的状态变化，包括同步（马上）和异步（一段时间）。

6. 本系列以 *《ES.Next 和未来》*（第 6 册）作为结尾，前瞻性地展望了 JS 的近中期未来，包括各种可能在不久之后出现在你的 JS 程序中的功能。

这就是阅读本系列丛书的预定顺序。

然而，第 2、3、4 册一般可以按照任何顺序阅读，这取决于你对哪一个主题感到最好奇，并愿意先探索。但我不建议你跳过这三本书中的任何一本书 —— 甚至包括 *《类型和语法》*，因为你们中的一些人想要这样做！—— 即使你认为你已经掌握了这个主题。

第 5 册（*《同步和异步》*）对于深入理解 JS 是至关重要的，但如果你开始钻研，发现它太吓人，这本书可以推迟到你对这门语言更有经验的时候再看。你写的 JS 越多（挣扎越多！），你就越会欣赏这本书。所以不要害怕在以后的时间再来读它。

系列的最后一本书，*《ES.Next 和未来》*，在某些方面是独立的。它可以像我建议的那样在最后读，如果你想找一条捷径来拓宽你的 JS 知识广度，也可以在 *《入门》* 之后直接读。这本书在未来也更有可能得到更新，所以你可能会想偶尔重新访问它。

无论你选择如何继续学习 YDKJSY，请先看看本书的附录，尤其是练习附录 B 中的代码片段，“练习、练习、练习！”。我有没有提到你应该去练习！？没有比写代码更好的学习方法了。
